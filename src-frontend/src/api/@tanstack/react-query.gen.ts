// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from "@tanstack/react-query";
import type { AxiosError } from "axios";

import { client } from "../client.gen";
import {
  addImageToAlbum,
  authGetCsrfToken,
  authLogin,
  authLogout,
  createAlbum,
  createGroups,
  deleteAlbum,
  deleteGroup,
  deleteImageFromAlbum,
  downloadAlbum,
  folderGetDetails,
  folderListRoots,
  getAllAlbums,
  getAllPeople,
  getAllPets,
  getGroup,
  getPersonDetail,
  getPersonImages,
  getPetDetail,
  getPetImages,
  getSingleAlbumInfo,
  getSystemSettings,
  getSystemStatistics,
  imageGetDate,
  imageGetLocation,
  imageGetMetadata,
  imageGetPeople,
  imageGetPets,
  imageGetThumbInfo,
  imageGetThumbnailsBulkInfo,
  imageUpdateDate,
  imageUpdateLocation,
  imageUpdateMetadata,
  listAllCountrySubdivisions,
  listAllFolders,
  listAllWorldCountries,
  listCountries,
  listGroups,
  listImages,
  listPossibleCountryCities,
  listSubdivisions,
  locationGetSubLocations,
  type Options,
  updateAlbumInfo,
  updateAlbumSorting,
  updateFolderInfo,
  updateGroup,
  updatePersonDetail,
  updatePet,
  updateSystemSettings,
  usersCreate,
  usersGetById,
  usersGetCurrent,
  usersGroupsList,
  usersGroupsUpdate,
  usersList,
  usersProfileGetById,
  usersProfileGetCurrent,
  usersProfileUpdate,
  usersUpdate,
} from "../sdk.gen";
import type {
  AddImageToAlbumData,
  AddImageToAlbumResponse,
  AuthGetCsrfTokenData,
  AuthGetCsrfTokenResponse,
  AuthLoginData,
  AuthLoginResponse,
  AuthLogoutData,
  AuthLogoutResponse,
  CreateAlbumData,
  CreateAlbumResponse,
  CreateGroupsData,
  CreateGroupsResponse,
  DeleteAlbumData,
  DeleteAlbumResponse,
  DeleteGroupData,
  DeleteGroupResponse,
  DeleteImageFromAlbumData,
  DeleteImageFromAlbumResponse,
  DownloadAlbumData,
  FolderGetDetailsData,
  FolderGetDetailsResponse,
  FolderListRootsData,
  FolderListRootsResponse,
  GetAllAlbumsData,
  GetAllAlbumsResponse,
  GetAllPeopleData,
  GetAllPeopleResponse,
  GetAllPetsData,
  GetAllPetsResponse,
  GetGroupData,
  GetGroupResponse,
  GetPersonDetailData,
  GetPersonDetailResponse,
  GetPersonImagesData,
  GetPersonImagesResponse,
  GetPetDetailData,
  GetPetDetailResponse,
  GetPetImagesData,
  GetPetImagesResponse,
  GetSingleAlbumInfoData,
  GetSingleAlbumInfoResponse,
  GetSystemSettingsData,
  GetSystemSettingsResponse,
  GetSystemStatisticsData,
  GetSystemStatisticsResponse,
  ImageGetDateData,
  ImageGetDateResponse,
  ImageGetLocationData,
  ImageGetLocationResponse,
  ImageGetMetadataData,
  ImageGetMetadataResponse,
  ImageGetPeopleData,
  ImageGetPeopleResponse,
  ImageGetPetsData,
  ImageGetPetsResponse,
  ImageGetThumbInfoData,
  ImageGetThumbInfoResponse,
  ImageGetThumbnailsBulkInfoData,
  ImageGetThumbnailsBulkInfoResponse,
  ImageUpdateDateData,
  ImageUpdateDateResponse,
  ImageUpdateLocationData,
  ImageUpdateLocationResponse,
  ImageUpdateMetadataData,
  ImageUpdateMetadataResponse,
  ListAllCountrySubdivisionsData,
  ListAllCountrySubdivisionsResponse,
  ListAllFoldersData,
  ListAllFoldersResponse,
  ListAllWorldCountriesData,
  ListAllWorldCountriesResponse,
  ListCountriesData,
  ListCountriesResponse,
  ListGroupsData,
  ListGroupsResponse,
  ListImagesData,
  ListImagesResponse,
  ListPossibleCountryCitiesData,
  ListPossibleCountryCitiesResponse,
  ListSubdivisionsData,
  ListSubdivisionsResponse,
  LocationGetSubLocationsData,
  LocationGetSubLocationsResponse,
  UpdateAlbumInfoData,
  UpdateAlbumInfoResponse,
  UpdateAlbumSortingData,
  UpdateAlbumSortingResponse,
  UpdateFolderInfoData,
  UpdateFolderInfoResponse,
  UpdateGroupData,
  UpdateGroupResponse,
  UpdatePersonDetailData,
  UpdatePersonDetailResponse,
  UpdatePetData,
  UpdatePetResponse,
  UpdateSystemSettingsData,
  UpdateSystemSettingsResponse,
  UsersCreateData,
  UsersCreateResponse,
  UsersGetByIdData,
  UsersGetByIdResponse,
  UsersGetCurrentData,
  UsersGetCurrentResponse,
  UsersGroupsListData,
  UsersGroupsListResponse,
  UsersGroupsUpdateData,
  UsersGroupsUpdateResponse,
  UsersListData,
  UsersListResponse,
  UsersProfileGetByIdData,
  UsersProfileGetByIdResponse,
  UsersProfileGetCurrentData,
  UsersProfileGetCurrentResponse,
  UsersProfileUpdateData,
  UsersProfileUpdateResponse,
  UsersUpdateData,
  UsersUpdateResponse,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseURL" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getAllAlbumsQueryKey = (options?: Options<GetAllAlbumsData>) =>
  createQueryKey("getAllAlbums", options);

/**
 * Get Albums
 *
 * List albums viewable by the current user
 */
export const getAllAlbumsOptions = (options?: Options<GetAllAlbumsData>) =>
  queryOptions<
    GetAllAlbumsResponse,
    AxiosError<DefaultError>,
    GetAllAlbumsResponse,
    ReturnType<typeof getAllAlbumsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllAlbums({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllAlbumsQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = { ...queryKey[0] };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getAllAlbumsInfiniteQueryKey = (
  options?: Options<GetAllAlbumsData>,
): QueryKey<Options<GetAllAlbumsData>> => createQueryKey("getAllAlbums", options, true);

/**
 * Get Albums
 *
 * List albums viewable by the current user
 */
export const getAllAlbumsInfiniteOptions = (options?: Options<GetAllAlbumsData>) =>
  infiniteQueryOptions<
    GetAllAlbumsResponse,
    AxiosError<DefaultError>,
    InfiniteData<GetAllAlbumsResponse>,
    QueryKey<Options<GetAllAlbumsData>>,
    number | Pick<QueryKey<Options<GetAllAlbumsData>>[0], "body" | "headers" | "path" | "query">
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllAlbumsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllAlbums({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllAlbumsInfiniteQueryKey(options),
    },
  );

/**
 * Create Album
 *
 * Create a new album with optional view/edit groups
 */
export const createAlbumMutation = (
  options?: Partial<Options<CreateAlbumData>>,
): UseMutationOptions<CreateAlbumResponse, AxiosError<DefaultError>, Options<CreateAlbumData>> => {
  const mutationOptions: UseMutationOptions<
    CreateAlbumResponse,
    AxiosError<DefaultError>,
    Options<CreateAlbumData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createAlbum({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Album
 */
export const deleteAlbumMutation = (
  options?: Partial<Options<DeleteAlbumData>>,
): UseMutationOptions<DeleteAlbumResponse, AxiosError<DefaultError>, Options<DeleteAlbumData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteAlbumResponse,
    AxiosError<DefaultError>,
    Options<DeleteAlbumData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteAlbum({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSingleAlbumInfoQueryKey = (options: Options<GetSingleAlbumInfoData>) =>
  createQueryKey("getSingleAlbumInfo", options);

/**
 * Get Album
 *
 * Retrieve full details of a single album
 */
export const getSingleAlbumInfoOptions = (options: Options<GetSingleAlbumInfoData>) =>
  queryOptions<
    GetSingleAlbumInfoResponse,
    AxiosError<DefaultError>,
    GetSingleAlbumInfoResponse,
    ReturnType<typeof getSingleAlbumInfoQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSingleAlbumInfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSingleAlbumInfoQueryKey(options),
  });

/**
 * Update Album
 *
 * Update album name, description, and group permissions
 */
export const updateAlbumInfoMutation = (
  options?: Partial<Options<UpdateAlbumInfoData>>,
): UseMutationOptions<
  UpdateAlbumInfoResponse,
  AxiosError<DefaultError>,
  Options<UpdateAlbumInfoData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAlbumInfoResponse,
    AxiosError<DefaultError>,
    Options<UpdateAlbumInfoData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateAlbumInfo({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Add Image To Album
 */
export const addImageToAlbumMutation = (
  options?: Partial<Options<AddImageToAlbumData>>,
): UseMutationOptions<
  AddImageToAlbumResponse,
  AxiosError<DefaultError>,
  Options<AddImageToAlbumData>
> => {
  const mutationOptions: UseMutationOptions<
    AddImageToAlbumResponse,
    AxiosError<DefaultError>,
    Options<AddImageToAlbumData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await addImageToAlbum({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const downloadAlbumQueryKey = (options: Options<DownloadAlbumData>) =>
  createQueryKey("downloadAlbum", options);

/**
 * Download Album
 *
 * Download all images in an album as a ZIP archive.
 * You can choose original or full-size paths. Requires view access.
 */
export const downloadAlbumOptions = (options: Options<DownloadAlbumData>) =>
  queryOptions<
    unknown,
    AxiosError<DefaultError>,
    unknown,
    ReturnType<typeof downloadAlbumQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await downloadAlbum({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: downloadAlbumQueryKey(options),
  });

/**
 * Remove Image From Album
 */
export const deleteImageFromAlbumMutation = (
  options?: Partial<Options<DeleteImageFromAlbumData>>,
): UseMutationOptions<
  DeleteImageFromAlbumResponse,
  AxiosError<DefaultError>,
  Options<DeleteImageFromAlbumData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteImageFromAlbumResponse,
    AxiosError<DefaultError>,
    Options<DeleteImageFromAlbumData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteImageFromAlbum({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Album Sorting
 *
 * Reorder images in the album using a list of image IDs
 */
export const updateAlbumSortingMutation = (
  options?: Partial<Options<UpdateAlbumSortingData>>,
): UseMutationOptions<
  UpdateAlbumSortingResponse,
  AxiosError<DefaultError>,
  Options<UpdateAlbumSortingData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAlbumSortingResponse,
    AxiosError<DefaultError>,
    Options<UpdateAlbumSortingData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateAlbumSorting({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authGetCsrfTokenQueryKey = (options?: Options<AuthGetCsrfTokenData>) =>
  createQueryKey("authGetCsrfToken", options);

/**
 * Get Csrf Token
 */
export const authGetCsrfTokenOptions = (options?: Options<AuthGetCsrfTokenData>) =>
  queryOptions<
    AuthGetCsrfTokenResponse,
    AxiosError<DefaultError>,
    AuthGetCsrfTokenResponse,
    ReturnType<typeof authGetCsrfTokenQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authGetCsrfToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authGetCsrfTokenQueryKey(options),
  });

/**
 * Login
 */
export const authLoginMutation = (
  options?: Partial<Options<AuthLoginData>>,
): UseMutationOptions<AuthLoginResponse, AxiosError<DefaultError>, Options<AuthLoginData>> => {
  const mutationOptions: UseMutationOptions<
    AuthLoginResponse,
    AxiosError<DefaultError>,
    Options<AuthLoginData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authLogin({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout
 */
export const authLogoutMutation = (
  options?: Partial<Options<AuthLogoutData>>,
): UseMutationOptions<AuthLogoutResponse, AxiosError<DefaultError>, Options<AuthLogoutData>> => {
  const mutationOptions: UseMutationOptions<
    AuthLogoutResponse,
    AxiosError<DefaultError>,
    Options<AuthLogoutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authLogout({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const folderListRootsQueryKey = (options?: Options<FolderListRootsData>) =>
  createQueryKey("folderListRoots", options);

/**
 * List Image Folders
 *
 * List root image folders with permission filtering
 */
export const folderListRootsOptions = (options?: Options<FolderListRootsData>) =>
  queryOptions<
    FolderListRootsResponse,
    AxiosError<DefaultError>,
    FolderListRootsResponse,
    ReturnType<typeof folderListRootsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await folderListRoots({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: folderListRootsQueryKey(options),
  });

export const listAllFoldersQueryKey = (options?: Options<ListAllFoldersData>) =>
  createQueryKey("listAllFolders", options);

/**
 * List All Image Folders
 *
 * List all image folders with permission filtering
 */
export const listAllFoldersOptions = (options?: Options<ListAllFoldersData>) =>
  queryOptions<
    ListAllFoldersResponse,
    AxiosError<DefaultError>,
    ListAllFoldersResponse,
    ReturnType<typeof listAllFoldersQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAllFolders({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAllFoldersQueryKey(options),
  });

export const folderGetDetailsQueryKey = (options: Options<FolderGetDetailsData>) =>
  createQueryKey("folderGetDetails", options);

/**
 * Get Image Folder
 *
 * Get details of a specific image folder with children and images
 */
export const folderGetDetailsOptions = (options: Options<FolderGetDetailsData>) =>
  queryOptions<
    FolderGetDetailsResponse,
    AxiosError<DefaultError>,
    FolderGetDetailsResponse,
    ReturnType<typeof folderGetDetailsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await folderGetDetails({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: folderGetDetailsQueryKey(options),
  });

/**
 * Update Folder
 */
export const updateFolderInfoMutation = (
  options?: Partial<Options<UpdateFolderInfoData>>,
): UseMutationOptions<
  UpdateFolderInfoResponse,
  AxiosError<DefaultError>,
  Options<UpdateFolderInfoData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFolderInfoResponse,
    AxiosError<DefaultError>,
    Options<UpdateFolderInfoData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateFolderInfo({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listGroupsQueryKey = (options?: Options<ListGroupsData>) =>
  createQueryKey("listGroups", options);

/**
 * List Groups
 *
 * Retrieves all groups.
 *
 * Returns:
 * A list of GroupOutSchema objects representing all groups.
 */
export const listGroupsOptions = (options?: Options<ListGroupsData>) =>
  queryOptions<
    ListGroupsResponse,
    AxiosError<DefaultError>,
    ListGroupsResponse,
    ReturnType<typeof listGroupsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listGroups({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listGroupsQueryKey(options),
  });

/**
 * Create Groups
 *
 * Creates one or more groups from a list of group schemas or a single group.
 *
 * Args:
 * request: The Django request object.
 * data: A GroupCreateInSchema object or list of GroupCreateInSchema objects.
 *
 * Returns:
 * A list of GroupOutSchema objects representing the created groups.
 */
export const createGroupsMutation = (
  options?: Partial<Options<CreateGroupsData>>,
): UseMutationOptions<
  CreateGroupsResponse,
  AxiosError<DefaultError>,
  Options<CreateGroupsData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateGroupsResponse,
    AxiosError<DefaultError>,
    Options<CreateGroupsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createGroups({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Group
 *
 * Deletes a single group by ID.
 *
 * Args:
 * group_id: The ID of the group to delete.
 *
 * Returns:
 * HTTP 204 No Content on successful deletion.
 */
export const deleteGroupMutation = (
  options?: Partial<Options<DeleteGroupData>>,
): UseMutationOptions<DeleteGroupResponse, AxiosError<DefaultError>, Options<DeleteGroupData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteGroupResponse,
    AxiosError<DefaultError>,
    Options<DeleteGroupData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteGroup({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getGroupQueryKey = (options: Options<GetGroupData>) =>
  createQueryKey("getGroup", options);

/**
 * Get Group
 *
 * Retrieves a single group by ID.
 *
 * Args:
 * group_id: The ID of the group to retrieve.
 *
 * Returns:
 * A GroupOutSchema object representing the requested group.
 */
export const getGroupOptions = (options: Options<GetGroupData>) =>
  queryOptions<
    GetGroupResponse,
    AxiosError<DefaultError>,
    GetGroupResponse,
    ReturnType<typeof getGroupQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGroupQueryKey(options),
  });

/**
 * Update Group
 *
 * Updates a single group's information.
 *
 * Args:
 * group_id: The ID of the group to update.
 * data: The updated group data.
 *
 * Returns:
 * A GroupOutSchema object representing the updated group.
 */
export const updateGroupMutation = (
  options?: Partial<Options<UpdateGroupData>>,
): UseMutationOptions<UpdateGroupResponse, AxiosError<DefaultError>, Options<UpdateGroupData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateGroupResponse,
    AxiosError<DefaultError>,
    Options<UpdateGroupData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateGroup({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listImagesQueryKey = (options?: Options<ListImagesData>) =>
  createQueryKey("listImages", options);

/**
 * List Images
 */
export const listImagesOptions = (options?: Options<ListImagesData>) =>
  queryOptions<
    ListImagesResponse,
    AxiosError<DefaultError>,
    ListImagesResponse,
    ReturnType<typeof listImagesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listImages({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listImagesQueryKey(options),
  });

export const listImagesInfiniteQueryKey = (
  options?: Options<ListImagesData>,
): QueryKey<Options<ListImagesData>> => createQueryKey("listImages", options, true);

/**
 * List Images
 */
export const listImagesInfiniteOptions = (options?: Options<ListImagesData>) =>
  infiniteQueryOptions<
    ListImagesResponse,
    AxiosError<DefaultError>,
    InfiniteData<ListImagesResponse>,
    QueryKey<Options<ListImagesData>>,
    number | Pick<QueryKey<Options<ListImagesData>>[0], "body" | "headers" | "path" | "query">
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListImagesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listImages({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listImagesInfiniteQueryKey(options),
    },
  );

/**
 * Get Image Thumbnails Bulk Info
 */
export const imageGetThumbnailsBulkInfoMutation = (
  options?: Partial<Options<ImageGetThumbnailsBulkInfoData>>,
): UseMutationOptions<
  ImageGetThumbnailsBulkInfoResponse,
  AxiosError<DefaultError>,
  Options<ImageGetThumbnailsBulkInfoData>
> => {
  const mutationOptions: UseMutationOptions<
    ImageGetThumbnailsBulkInfoResponse,
    AxiosError<DefaultError>,
    Options<ImageGetThumbnailsBulkInfoData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await imageGetThumbnailsBulkInfo({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const imageGetDateQueryKey = (options: Options<ImageGetDateData>) =>
  createQueryKey("imageGetDate", options);

/**
 * Get Image Date
 */
export const imageGetDateOptions = (options: Options<ImageGetDateData>) =>
  queryOptions<
    ImageGetDateResponse,
    AxiosError<DefaultError>,
    ImageGetDateResponse,
    ReturnType<typeof imageGetDateQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await imageGetDate({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: imageGetDateQueryKey(options),
  });

/**
 * Update Image Date
 */
export const imageUpdateDateMutation = (
  options?: Partial<Options<ImageUpdateDateData>>,
): UseMutationOptions<
  ImageUpdateDateResponse,
  AxiosError<DefaultError>,
  Options<ImageUpdateDateData>
> => {
  const mutationOptions: UseMutationOptions<
    ImageUpdateDateResponse,
    AxiosError<DefaultError>,
    Options<ImageUpdateDateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await imageUpdateDate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const imageGetLocationQueryKey = (options: Options<ImageGetLocationData>) =>
  createQueryKey("imageGetLocation", options);

/**
 * Get Image Location
 */
export const imageGetLocationOptions = (options: Options<ImageGetLocationData>) =>
  queryOptions<
    ImageGetLocationResponse,
    AxiosError<DefaultError>,
    ImageGetLocationResponse,
    ReturnType<typeof imageGetLocationQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await imageGetLocation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: imageGetLocationQueryKey(options),
  });

/**
 * Update Image Location
 */
export const imageUpdateLocationMutation = (
  options?: Partial<Options<ImageUpdateLocationData>>,
): UseMutationOptions<
  ImageUpdateLocationResponse,
  AxiosError<DefaultError>,
  Options<ImageUpdateLocationData>
> => {
  const mutationOptions: UseMutationOptions<
    ImageUpdateLocationResponse,
    AxiosError<DefaultError>,
    Options<ImageUpdateLocationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await imageUpdateLocation({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const imageGetMetadataQueryKey = (options: Options<ImageGetMetadataData>) =>
  createQueryKey("imageGetMetadata", options);

/**
 * Get Image Details
 */
export const imageGetMetadataOptions = (options: Options<ImageGetMetadataData>) =>
  queryOptions<
    ImageGetMetadataResponse,
    AxiosError<DefaultError>,
    ImageGetMetadataResponse,
    ReturnType<typeof imageGetMetadataQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await imageGetMetadata({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: imageGetMetadataQueryKey(options),
  });

/**
 * Update Image Details
 */
export const imageUpdateMetadataMutation = (
  options?: Partial<Options<ImageUpdateMetadataData>>,
): UseMutationOptions<
  ImageUpdateMetadataResponse,
  AxiosError<DefaultError>,
  Options<ImageUpdateMetadataData>
> => {
  const mutationOptions: UseMutationOptions<
    ImageUpdateMetadataResponse,
    AxiosError<DefaultError>,
    Options<ImageUpdateMetadataData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await imageUpdateMetadata({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const imageGetPeopleQueryKey = (options: Options<ImageGetPeopleData>) =>
  createQueryKey("imageGetPeople", options);

/**
 * Get Image People
 */
export const imageGetPeopleOptions = (options: Options<ImageGetPeopleData>) =>
  queryOptions<
    ImageGetPeopleResponse,
    AxiosError<DefaultError>,
    ImageGetPeopleResponse,
    ReturnType<typeof imageGetPeopleQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await imageGetPeople({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: imageGetPeopleQueryKey(options),
  });

export const imageGetPetsQueryKey = (options: Options<ImageGetPetsData>) =>
  createQueryKey("imageGetPets", options);

/**
 * Get Image Pets
 */
export const imageGetPetsOptions = (options: Options<ImageGetPetsData>) =>
  queryOptions<
    ImageGetPetsResponse,
    AxiosError<DefaultError>,
    ImageGetPetsResponse,
    ReturnType<typeof imageGetPetsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await imageGetPets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: imageGetPetsQueryKey(options),
  });

export const imageGetThumbInfoQueryKey = (options: Options<ImageGetThumbInfoData>) =>
  createQueryKey("imageGetThumbInfo", options);

/**
 * Get Image Thumbnail Info
 */
export const imageGetThumbInfoOptions = (options: Options<ImageGetThumbInfoData>) =>
  queryOptions<
    ImageGetThumbInfoResponse,
    AxiosError<DefaultError>,
    ImageGetThumbInfoResponse,
    ReturnType<typeof imageGetThumbInfoQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await imageGetThumbInfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: imageGetThumbInfoQueryKey(options),
  });

export const listPossibleCountryCitiesQueryKey = (
  options: Options<ListPossibleCountryCitiesData>,
) => createQueryKey("listPossibleCountryCities", options);

/**
 * Get Existing Cities
 */
export const listPossibleCountryCitiesOptions = (
  options: Options<ListPossibleCountryCitiesData>,
) =>
  queryOptions<
    ListPossibleCountryCitiesResponse,
    AxiosError<DefaultError>,
    ListPossibleCountryCitiesResponse,
    ReturnType<typeof listPossibleCountryCitiesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listPossibleCountryCities({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listPossibleCountryCitiesQueryKey(options),
  });

export const listCountriesQueryKey = (options?: Options<ListCountriesData>) =>
  createQueryKey("listCountries", options);

/**
 * Get Countries With Images In Them
 *
 * List all countries where images have been taken
 */
export const listCountriesOptions = (options?: Options<ListCountriesData>) =>
  queryOptions<
    ListCountriesResponse,
    AxiosError<DefaultError>,
    ListCountriesResponse,
    ReturnType<typeof listCountriesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listCountriesQueryKey(options),
  });

export const listAllWorldCountriesQueryKey = (options?: Options<ListAllWorldCountriesData>) =>
  createQueryKey("listAllWorldCountries", options);

/**
 * Get All Countries
 *
 * List all countries in the world, as per ISO-3166-1
 */
export const listAllWorldCountriesOptions = (options?: Options<ListAllWorldCountriesData>) =>
  queryOptions<
    ListAllWorldCountriesResponse,
    AxiosError<DefaultError>,
    ListAllWorldCountriesResponse,
    ReturnType<typeof listAllWorldCountriesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAllWorldCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAllWorldCountriesQueryKey(options),
  });

export const listSubdivisionsQueryKey = (options: Options<ListSubdivisionsData>) =>
  createQueryKey("listSubdivisions", options);

/**
 * Get Subdivisions With Images In Them
 *
 * List all subdivisions/states where images have been taken, filtered by country code
 */
export const listSubdivisionsOptions = (options: Options<ListSubdivisionsData>) =>
  queryOptions<
    ListSubdivisionsResponse,
    AxiosError<DefaultError>,
    ListSubdivisionsResponse,
    ReturnType<typeof listSubdivisionsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listSubdivisions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listSubdivisionsQueryKey(options),
  });

export const listAllCountrySubdivisionsQueryKey = (
  options: Options<ListAllCountrySubdivisionsData>,
) => createQueryKey("listAllCountrySubdivisions", options);

/**
 * Get Subdivisions For Country
 *
 * List all subdivisions of a given country, as per ISO-3166-2
 */
export const listAllCountrySubdivisionsOptions = (
  options: Options<ListAllCountrySubdivisionsData>,
) =>
  queryOptions<
    ListAllCountrySubdivisionsResponse,
    AxiosError<DefaultError>,
    ListAllCountrySubdivisionsResponse,
    ReturnType<typeof listAllCountrySubdivisionsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAllCountrySubdivisions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAllCountrySubdivisionsQueryKey(options),
  });

export const locationGetSubLocationsQueryKey = (options: Options<LocationGetSubLocationsData>) =>
  createQueryKey("locationGetSubLocations", options);

/**
 * Get Existing Sublocations
 */
export const locationGetSubLocationsOptions = (options: Options<LocationGetSubLocationsData>) =>
  queryOptions<
    LocationGetSubLocationsResponse,
    AxiosError<DefaultError>,
    LocationGetSubLocationsResponse,
    ReturnType<typeof locationGetSubLocationsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await locationGetSubLocations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: locationGetSubLocationsQueryKey(options),
  });

export const getAllPeopleQueryKey = (options?: Options<GetAllPeopleData>) =>
  createQueryKey("getAllPeople", options);

/**
 * Get All People
 */
export const getAllPeopleOptions = (options?: Options<GetAllPeopleData>) =>
  queryOptions<
    GetAllPeopleResponse,
    AxiosError<DefaultError>,
    GetAllPeopleResponse,
    ReturnType<typeof getAllPeopleQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllPeople({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllPeopleQueryKey(options),
  });

export const getAllPeopleInfiniteQueryKey = (
  options?: Options<GetAllPeopleData>,
): QueryKey<Options<GetAllPeopleData>> => createQueryKey("getAllPeople", options, true);

/**
 * Get All People
 */
export const getAllPeopleInfiniteOptions = (options?: Options<GetAllPeopleData>) =>
  infiniteQueryOptions<
    GetAllPeopleResponse,
    AxiosError<DefaultError>,
    InfiniteData<GetAllPeopleResponse>,
    QueryKey<Options<GetAllPeopleData>>,
    number | Pick<QueryKey<Options<GetAllPeopleData>>[0], "body" | "headers" | "path" | "query">
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllPeopleData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllPeople({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllPeopleInfiniteQueryKey(options),
    },
  );

export const getPersonDetailQueryKey = (options: Options<GetPersonDetailData>) =>
  createQueryKey("getPersonDetail", options);

/**
 * Get Person Detail
 */
export const getPersonDetailOptions = (options: Options<GetPersonDetailData>) =>
  queryOptions<
    GetPersonDetailResponse,
    AxiosError<DefaultError>,
    GetPersonDetailResponse,
    ReturnType<typeof getPersonDetailQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonDetail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonDetailQueryKey(options),
  });

/**
 * Update Person
 */
export const updatePersonDetailMutation = (
  options?: Partial<Options<UpdatePersonDetailData>>,
): UseMutationOptions<
  UpdatePersonDetailResponse,
  AxiosError<DefaultError>,
  Options<UpdatePersonDetailData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdatePersonDetailResponse,
    AxiosError<DefaultError>,
    Options<UpdatePersonDetailData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updatePersonDetail({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getPersonImagesQueryKey = (options: Options<GetPersonImagesData>) =>
  createQueryKey("getPersonImages", options);

/**
 * Get Person Images
 */
export const getPersonImagesOptions = (options: Options<GetPersonImagesData>) =>
  queryOptions<
    GetPersonImagesResponse,
    AxiosError<DefaultError>,
    GetPersonImagesResponse,
    ReturnType<typeof getPersonImagesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonImages({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonImagesQueryKey(options),
  });

export const getPersonImagesInfiniteQueryKey = (
  options: Options<GetPersonImagesData>,
): QueryKey<Options<GetPersonImagesData>> => createQueryKey("getPersonImages", options, true);

/**
 * Get Person Images
 */
export const getPersonImagesInfiniteOptions = (options: Options<GetPersonImagesData>) =>
  infiniteQueryOptions<
    GetPersonImagesResponse,
    AxiosError<DefaultError>,
    InfiniteData<GetPersonImagesResponse>,
    QueryKey<Options<GetPersonImagesData>>,
    number | Pick<QueryKey<Options<GetPersonImagesData>>[0], "body" | "headers" | "path" | "query">
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPersonImagesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersonImages({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPersonImagesInfiniteQueryKey(options),
    },
  );

export const getAllPetsQueryKey = (options?: Options<GetAllPetsData>) =>
  createQueryKey("getAllPets", options);

/**
 * Get All Pets
 */
export const getAllPetsOptions = (options?: Options<GetAllPetsData>) =>
  queryOptions<
    GetAllPetsResponse,
    AxiosError<DefaultError>,
    GetAllPetsResponse,
    ReturnType<typeof getAllPetsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllPets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllPetsQueryKey(options),
  });

export const getAllPetsInfiniteQueryKey = (
  options?: Options<GetAllPetsData>,
): QueryKey<Options<GetAllPetsData>> => createQueryKey("getAllPets", options, true);

/**
 * Get All Pets
 */
export const getAllPetsInfiniteOptions = (options?: Options<GetAllPetsData>) =>
  infiniteQueryOptions<
    GetAllPetsResponse,
    AxiosError<DefaultError>,
    InfiniteData<GetAllPetsResponse>,
    QueryKey<Options<GetAllPetsData>>,
    number | Pick<QueryKey<Options<GetAllPetsData>>[0], "body" | "headers" | "path" | "query">
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllPetsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllPets({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllPetsInfiniteQueryKey(options),
    },
  );

export const getPetDetailQueryKey = (options: Options<GetPetDetailData>) =>
  createQueryKey("getPetDetail", options);

/**
 * Get Single Pet
 */
export const getPetDetailOptions = (options: Options<GetPetDetailData>) =>
  queryOptions<
    GetPetDetailResponse,
    AxiosError<DefaultError>,
    GetPetDetailResponse,
    ReturnType<typeof getPetDetailQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPetDetail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPetDetailQueryKey(options),
  });

/**
 * Update Pet
 */
export const updatePetMutation = (
  options?: Partial<Options<UpdatePetData>>,
): UseMutationOptions<UpdatePetResponse, AxiosError<DefaultError>, Options<UpdatePetData>> => {
  const mutationOptions: UseMutationOptions<
    UpdatePetResponse,
    AxiosError<DefaultError>,
    Options<UpdatePetData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updatePet({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getPetImagesQueryKey = (options: Options<GetPetImagesData>) =>
  createQueryKey("getPetImages", options);

/**
 * Get Person Images
 */
export const getPetImagesOptions = (options: Options<GetPetImagesData>) =>
  queryOptions<
    GetPetImagesResponse,
    AxiosError<DefaultError>,
    GetPetImagesResponse,
    ReturnType<typeof getPetImagesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPetImages({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPetImagesQueryKey(options),
  });

export const getPetImagesInfiniteQueryKey = (
  options: Options<GetPetImagesData>,
): QueryKey<Options<GetPetImagesData>> => createQueryKey("getPetImages", options, true);

/**
 * Get Person Images
 */
export const getPetImagesInfiniteOptions = (options: Options<GetPetImagesData>) =>
  infiniteQueryOptions<
    GetPetImagesResponse,
    AxiosError<DefaultError>,
    InfiniteData<GetPetImagesResponse>,
    QueryKey<Options<GetPetImagesData>>,
    number | Pick<QueryKey<Options<GetPetImagesData>>[0], "body" | "headers" | "path" | "query">
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetPetImagesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPetImages({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPetImagesInfiniteQueryKey(options),
    },
  );

export const getSystemSettingsQueryKey = (options?: Options<GetSystemSettingsData>) =>
  createQueryKey("getSystemSettings", options);

/**
 * Get System Settings
 */
export const getSystemSettingsOptions = (options?: Options<GetSystemSettingsData>) =>
  queryOptions<
    GetSystemSettingsResponse,
    AxiosError<DefaultError>,
    GetSystemSettingsResponse,
    ReturnType<typeof getSystemSettingsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSystemSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSystemSettingsQueryKey(options),
  });

/**
 * Update System Settings
 */
export const updateSystemSettingsMutation = (
  options?: Partial<Options<UpdateSystemSettingsData>>,
): UseMutationOptions<
  UpdateSystemSettingsResponse,
  AxiosError<DefaultError>,
  Options<UpdateSystemSettingsData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSystemSettingsResponse,
    AxiosError<DefaultError>,
    Options<UpdateSystemSettingsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateSystemSettings({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSystemStatisticsQueryKey = (options?: Options<GetSystemStatisticsData>) =>
  createQueryKey("getSystemStatistics", options);

/**
 * Get System Statistics
 *
 * Returns statistics about the system, including counts of various objects
 * and disk space usage, filtered by the current user's view/edit permissions.
 * System-wide object counts are no longer exposed to prevent information leakage.
 */
export const getSystemStatisticsOptions = (options?: Options<GetSystemStatisticsData>) =>
  queryOptions<
    GetSystemStatisticsResponse,
    AxiosError<DefaultError>,
    GetSystemStatisticsResponse,
    ReturnType<typeof getSystemStatisticsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSystemStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSystemStatisticsQueryKey(options),
  });

export const usersListQueryKey = (options?: Options<UsersListData>) =>
  createQueryKey("usersList", options);

/**
 * Users List
 *
 * Get all users with filtering and pagination.
 */
export const usersListOptions = (options?: Options<UsersListData>) =>
  queryOptions<
    UsersListResponse,
    AxiosError<DefaultError>,
    UsersListResponse,
    ReturnType<typeof usersListQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersListQueryKey(options),
  });

/**
 * Users Create
 *
 * Create a new user with proper permission checks and validation.
 */
export const usersCreateMutation = (
  options?: Partial<Options<UsersCreateData>>,
): UseMutationOptions<UsersCreateResponse, AxiosError<DefaultError>, Options<UsersCreateData>> => {
  const mutationOptions: UseMutationOptions<
    UsersCreateResponse,
    AxiosError<DefaultError>,
    Options<UsersCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await usersCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersGetCurrentQueryKey = (options?: Options<UsersGetCurrentData>) =>
  createQueryKey("usersGetCurrent", options);

/**
 * Users Get Current
 *
 * Get current user's information.
 */
export const usersGetCurrentOptions = (options?: Options<UsersGetCurrentData>) =>
  queryOptions<
    UsersGetCurrentResponse,
    AxiosError<DefaultError>,
    UsersGetCurrentResponse,
    ReturnType<typeof usersGetCurrentQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersGetCurrent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersGetCurrentQueryKey(options),
  });

export const usersProfileGetCurrentQueryKey = (options?: Options<UsersProfileGetCurrentData>) =>
  createQueryKey("usersProfileGetCurrent", options);

/**
 * Users Profile Get Current
 *
 * Get current user's profile.
 */
export const usersProfileGetCurrentOptions = (options?: Options<UsersProfileGetCurrentData>) =>
  queryOptions<
    UsersProfileGetCurrentResponse,
    AxiosError<DefaultError>,
    UsersProfileGetCurrentResponse,
    ReturnType<typeof usersProfileGetCurrentQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersProfileGetCurrent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersProfileGetCurrentQueryKey(options),
  });

export const usersGroupsListQueryKey = (options: Options<UsersGroupsListData>) =>
  createQueryKey("usersGroupsList", options);

/**
 * Users Groups List
 *
 * Get user's groups with permission checks.
 */
export const usersGroupsListOptions = (options: Options<UsersGroupsListData>) =>
  queryOptions<
    UsersGroupsListResponse,
    AxiosError<DefaultError>,
    UsersGroupsListResponse,
    ReturnType<typeof usersGroupsListQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersGroupsList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersGroupsListQueryKey(options),
  });

/**
 * Users Groups Update
 *
 * Set user's groups with validation.
 */
export const usersGroupsUpdateMutation = (
  options?: Partial<Options<UsersGroupsUpdateData>>,
): UseMutationOptions<
  UsersGroupsUpdateResponse,
  AxiosError<DefaultError>,
  Options<UsersGroupsUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersGroupsUpdateResponse,
    AxiosError<DefaultError>,
    Options<UsersGroupsUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await usersGroupsUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersGetByIdQueryKey = (options: Options<UsersGetByIdData>) =>
  createQueryKey("usersGetById", options);

/**
 * Users Get By Id
 *
 * Get user information with proper permission checks.
 */
export const usersGetByIdOptions = (options: Options<UsersGetByIdData>) =>
  queryOptions<
    UsersGetByIdResponse,
    AxiosError<DefaultError>,
    UsersGetByIdResponse,
    ReturnType<typeof usersGetByIdQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersGetById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersGetByIdQueryKey(options),
  });

/**
 * Users Update
 *
 * Update user information with proper permission and validation checks.
 */
export const usersUpdateMutation = (
  options?: Partial<Options<UsersUpdateData>>,
): UseMutationOptions<UsersUpdateResponse, AxiosError<DefaultError>, Options<UsersUpdateData>> => {
  const mutationOptions: UseMutationOptions<
    UsersUpdateResponse,
    AxiosError<DefaultError>,
    Options<UsersUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await usersUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersProfileGetByIdQueryKey = (options: Options<UsersProfileGetByIdData>) =>
  createQueryKey("usersProfileGetById", options);

/**
 * Users Profile Get By Id
 *
 * Get user profile with permission checks.
 */
export const usersProfileGetByIdOptions = (options: Options<UsersProfileGetByIdData>) =>
  queryOptions<
    UsersProfileGetByIdResponse,
    AxiosError<DefaultError>,
    UsersProfileGetByIdResponse,
    ReturnType<typeof usersProfileGetByIdQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersProfileGetById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersProfileGetByIdQueryKey(options),
  });

/**
 * Users Profile Update
 *
 * Edit user profile with permission checks.
 */
export const usersProfileUpdateMutation = (
  options?: Partial<Options<UsersProfileUpdateData>>,
): UseMutationOptions<
  UsersProfileUpdateResponse,
  AxiosError<DefaultError>,
  Options<UsersProfileUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersProfileUpdateResponse,
    AxiosError<DefaultError>,
    Options<UsersProfileUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await usersProfileUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
